<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>手势切水果 Demo</title>
  <!-- 引入 MediaPipe Hands 和 Camera Utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #333;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }
    
    /* 游戏容器 */
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* 摄像头画面（用于调试，也可以设为 hidden 隐藏） */
    .input_video {
      position: absolute;
      top: 0;
      left: 0;
      width: 320px;
      height: 240px;
      opacity: 0.3; /* 半透明显示在左上角作为参考 */
      z-index: 1;
      transform: scaleX(-1); /* 镜像翻转 */
    }

    /* 游戏主画布 */
    .output_canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 2;
      /* 镜像翻转，让操作更符合直觉 */
      transform: scaleX(-1); 
    }

    /* UI 覆盖层（不镜像翻转，否则文字会反） */
    #ui-layer {
      position: absolute;
      top: 20px;
      right: 30px;
      z-index: 10;
      color: white;
      text-align: right;
      pointer-events: none; /* 让点击穿透 */
    }

    h1 { margin: 0; font-size: 24px; text-shadow: 2px 2px 4px #000; }
    p { margin: 5px 0; font-size: 36px; font-weight: bold; text-shadow: 2px 2px 4px #000; }
    .label { font-size: 14px; opacity: 0.8; }
  </style>
</head>
<body>

<div id="game-container">
  <video class="input_video"></video>
  <canvas class="output_canvas"></canvas>
  
  <!-- UI 显示区域 -->
  <div id="ui-layer">
    <div>
      <span class="label">倒计时</span>
      <p id="timer">60</p>
    </div>
    <div style="margin-top: 20px;">
      <span class="label">得分</span>
      <p id="score">0</p>
    </div>
  </div>
</div>

<script>
  // --- 1. 初始化变量 ---
  const videoElement = document.getElementsByClassName('input_video')[0];
  const canvasElement = document.getElementsByClassName('output_canvas')[0];
  const canvasCtx = canvasElement.getContext('2d');
  
  const scoreElement = document.getElementById('score');
  const timerElement = document.getElementById('timer');

  let score = 0;
  let timeLeft = 60;
  let isGameOver = false;
  let handPosition = { x: -1, y: -1 }; // 存储检测到的手部位置（归一化 0.0 ~ 1.0）

  // 水果数组
  let fruits = []; 
  // 水果生成间隔
  let lastSpawnTime = 0;
  const spawnInterval = 1000; // 毫秒

  // --- 2. 设置 MediaPipe Hands ---
  const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
  }});

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  hands.onResults(onResults);

  // 启动摄像头
  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await hands.send({image: videoElement});
    },
    width: 1280,
    height: 720
  });
  camera.start();

  // --- 3. 游戏逻辑核心 ---

  // 处理手势识别结果
  function onResults(results) {
    // 保存当前画布尺寸，用于坐标转换
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // 3.1 获取食指位置
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      const landmarks = results.multiHandLandmarks[0];
      
      // 获取食指指尖 (Index Finger Tip, 索引为 8)
      const indexFinger = landmarks[8];
      
      // MediaPipe 返回的是归一化坐标 (0~1)
      handPosition = { x: indexFinger.x, y: indexFinger.y };

      // 可选：画出手部骨架
      drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
      drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2});
      
      // 画出“刀光”或者指尖位置
      const cx = handPosition.x * canvasElement.width;
      const cy = handPosition.y * canvasElement.height;
      
      canvasCtx.beginPath();
      canvasCtx.arc(cx, cy, 15, 0, 2 * Math.PI);
      canvasCtx.fillStyle = "yellow";
      canvasCtx.fill();
      canvasCtx.strokeStyle = "white";
      canvasCtx.stroke();
    } else {
      handPosition = { x: -1, y: -1 }; // 没检测到手
    }

    // 3.2 运行游戏循环 (绘制水果、检测碰撞)
    if (!isGameOver) {
      updateGame(canvasElement.width, canvasElement.height);
    } else {
      drawGameOver();
    }

    canvasCtx.restore();
  }

  // 游戏更新循环
  function updateGame(width, height) {
    const now = Date.now();

    // 生成水果
    if (now - lastSpawnTime > spawnInterval) {
      spawnFruit(width, height);
      lastSpawnTime = now;
    }

    // 更新和绘制所有水果
    for (let i = fruits.length - 1; i >= 0; i--) {
      let fruit = fruits[i];
      
      // 移动水果 (向上抛出然后受重力下落，这里简单做成向上飘或者线性移动)
      // 简单模拟：从下往上飘
      fruit.y -= fruit.speed; 
      
      // 绘制水果
      canvasCtx.beginPath();
      canvasCtx.arc(fruit.x, fruit.y, fruit.radius, 0, 2 * Math.PI);
      canvasCtx.fillStyle = fruit.color;
      canvasCtx.fill();
      canvasCtx.lineWidth = 3;
      canvasCtx.strokeStyle = "white";
      canvasCtx.stroke();

      // 检测碰撞 (切水果)
      if (checkCollision(fruit, handPosition, width, height)) {
        // 切到了！
        score += 10;
        scoreElement.innerText = score;
        fruits.splice(i, 1); // 移除水果
        continue;
      }

      // 移除超出屏幕的水果
      if (fruit.y + fruit.radius < 0) {
        fruits.splice(i, 1);
      }
    }
  }

  function spawnFruit(width, height) {
    const radius = 30 + Math.random() * 20; // 半径 30~50
    const x = Math.random() * width;
    const y = height + radius; // 从底部生成
    const speed = 2 + Math.random() * 3; // 速度
    const color = `hsl(${Math.random() * 360}, 70%, 50%)`; // 随机颜色

    fruits.push({
      x: x,
      y: y,
      radius: radius,
      speed: speed,
      color: color
    });
  }

  // 碰撞检测：圆（水果）与 点（手指）
  function checkCollision(fruit, hand, width, height) {
    if (hand.x === -1) return false;

    // 转换手指坐标到像素
    const handPixelX = hand.x * width;
    const handPixelY = hand.y * height;

    const dx = handPixelX - fruit.x;
    const dy = handPixelY - fruit.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    return distance < fruit.radius;
  }

  function drawGameOver() {
    canvasCtx.font = "50px Arial";
    canvasCtx.fillStyle = "white";
    canvasCtx.textAlign = "center";
    canvasCtx.fillText("游戏结束", canvasElement.width / 2, canvasElement.height / 2);
    canvasCtx.font = "30px Arial";
    canvasCtx.fillText(`最终得分: ${score}`, canvasElement.width / 2, canvasElement.height / 2 + 50);
  }

  // --- 4. 倒计时逻辑 ---
  const timerInterval = setInterval(() => {
    if (timeLeft > 0) {
      timeLeft--;
      timerElement.innerText = timeLeft;
    } else {
      isGameOver = true;
      clearInterval(timerInterval);
    }
  }, 1000);

</script>
</body>
</html>