<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>æ‰‹åŠ¿åˆ‡æ°´æœ + éšè—è´ªåƒè›‡</title>
  <!-- MediaPipe ä¾èµ– -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body {
      margin: 0; padding: 0;
      background-color: #1a1a1a;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
    }

    /* å®¹å™¨ */
    #game-container {
      position: relative;
      width: 100vw; height: 100vh;
      display: flex; justify-content: center; align-items: center;
      background: radial-gradient(circle, #2c3e50 0%, #000000 100%);
    }

    /* æ‘„åƒå¤´å°çª— */
    .input_video {
      position: absolute; top: 0; left: 0;
      width: 160px; height: 120px;
      opacity: 0.6; z-index: 1;
      transform: scaleX(-1);
      border-bottom-right-radius: 10px;
      border: 2px solid rgba(255,255,255,0.2);
    }

    /* ä¸»ç”»å¸ƒ */
    .output_canvas {
      position: absolute; width: 100%; height: 100%;
      z-index: 2;
      transform: scaleX(-1); /* é•œåƒ */
    }

    /* UI å±‚ */
    #ui-layer {
      position: absolute; width: 100%; height: 100%;
      z-index: 10; pointer-events: none;
    }

    /* åˆ‡æ°´æœ HUD */
    #fruit-hud {
      position: absolute; top: 20px; right: 30px;
      text-align: right; color: white; display: none;
    }
    .hud-value { font-size: 42px; font-weight: 800; font-family: monospace; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
    .cake-counter { font-size: 24px; color: #ff9ff3; margin-top: 10px; }

    /* è´ªåƒè›‡ HUD */
    #snake-hud {
      position: absolute; top: 20px; left: 30px;
      text-align: left; color: #2ed573; display: none;
    }
    
    /* èœå•é®ç½© */
    .menu-overlay {
      position: absolute; width: 100%; height: 100%;
      z-index: 20; background: rgba(0, 0, 0, 0.85);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      color: white; backdrop-filter: blur(5px);
      pointer-events: auto; /* å…è®¸ç‚¹å‡» */
    }
    .hidden { display: none !important; }

    h1 { font-size: 60px; margin: 0 0 20px 0; color: #f39c12; text-shadow: 0 0 20px #e67e22; }
    h2 { font-size: 40px; color: #e74c3c; }
    
    .btn {
      padding: 15px 40px; font-size: 24px;
      background: linear-gradient(45deg, #e67e22, #d35400);
      color: white; border: none; border-radius: 50px;
      cursor: pointer; transition: 0.2s;
      box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4);
    }
    .btn:hover { transform: scale(1.05); }

    /* è´ªåƒè›‡æç¤º */
    .snake-instruction {
      position: absolute; bottom: 10%; width: 100%;
      text-align: center; color: rgba(255,255,255,0.5); font-size: 18px;
    }
  </style>
</head>
<body>

<div id="game-container">
  <video class="input_video"></video>
  <canvas class="output_canvas"></canvas>

  <!-- UI å±‚ -->
  <div id="ui-layer">
    <!-- åˆ‡æ°´æœ HUD -->
    <div id="fruit-hud">
      <div>SCORE <span id="score-val" class="hud-value">0</span></div>
      <div>TIME <span id="timer-val" class="hud-value">60</span></div>
      <div class="cake-counter">ğŸ‚ è›‹ç³•æ”¶é›†: <span id="cake-val">0</span>/5</div>
    </div>

    <!-- è´ªåƒè›‡ HUD -->
    <div id="snake-hud">
      <h2>ğŸ éšè—æ¨¡å¼: è´ªåƒè›‡</h2>
      <div>é•¿åº¦: <span id="snake-score" class="hud-value">0</span></div>
      <div class="snake-instruction">æ‰‹æŒç›¸å¯¹äºå±å¹•ä¸­å¿ƒçš„ä½ç½®æ§åˆ¶æ–¹å‘</div>
    </div>
  </div>

  <!-- å¼€å§‹èœå• -->
  <div id="start-screen" class="menu-overlay">
    <h1>ğŸ å¿è€…åˆ‡æ°´æœ ğŸ‰</h1>
    <p style="margin-bottom: 40px; font-size: 20px; color: #aaa;">
      åˆ‡å¼€æ°´æœå¾—åˆ†ï¼Œå°å¿ƒç‚¸å¼¹ã€‚<br>
      <span style="color: #ff9ff3;">é›†é½ 5 ä¸ªè›‹ç³•è¿›å…¥éšè—ä¸–ç•Œï¼</span>
    </p>
    <button class="btn" onclick="startGame('fruit')">å¼€å§‹æ¸¸æˆ</button>
  </div>

  <!-- æ¸¸æˆç»“æŸèœå• -->
  <div id="game-over-screen" class="menu-overlay hidden">
    <h2 id="go-title">æ¸¸æˆç»“æŸ</h2>
    <div style="font-size: 30px; margin-bottom: 20px;">å¾—åˆ†: <span id="final-score" style="color: gold;">0</span></div>
    <div id="go-reason" style="color: #ff6b6b; margin-bottom: 30px;"></div>
    <button class="btn" onclick="startGame('fruit')">å†æ¥ä¸€å±€</button>
  </div>
</div>

<script>
  // ================= é…ç½®ä¸çŠ¶æ€ =================
  const videoElement = document.getElementsByClassName('input_video')[0];
  const canvasElement = document.getElementsByClassName('output_canvas')[0];
  const ctx = canvasElement.getContext('2d');

  // æ¸¸æˆæ¨¡å¼: 'MENU', 'FRUIT_PLAY', 'FRUIT_OVER', 'SNAKE_PLAY', 'SNAKE_OVER'
  let currentState = 'MENU'; 
  
  // MediaPipe æ‰‹éƒ¨æ•°æ®
  let handResults = null;
  let handPos = { x: -1, y: -1 }; // å½’ä¸€åŒ– 0-1
  
  // --- åˆ‡æ°´æœå˜é‡ ---
  let fruitScore = 0;
  let fruitTime = 60;
  let fruitTimerRef = null;
  let cakeCount = 0;
  let fruits = [];
  let particles = [];
  let lastSpawnTime = 0;
  
  const FRUIT_GRAVITY = 0.2; // é‡åŠ›
  const FRUIT_TYPES = ['ğŸ','ğŸŠ','ğŸ‰','ğŸ¥','ğŸ¥¥','ğŸ‡'];
  const BOMB_TYPE = { icon: 'ğŸ’£', type: 'bomb' };
  const CAKE_TYPE = { icon: 'ğŸ‚', type: 'cake' };

  // --- è´ªåƒè›‡å˜é‡ ---
  let snake = []; // èº«ä½“æ•°ç»„
  let snakeDir = { x: 0, y: -1 }; // åˆå§‹å‘ä¸Š
  let snakeFood = { x: 0, y: 0 };
  let snakeGridSize = 30; // æ ¼å­å¤§å°
  let snakeMoveTimer = 0;
  let snakeMoveInterval = 150; // è›‡ç§»åŠ¨é€Ÿåº¦ (ms)
  let snakeScore = 0;

  // ================= MediaPipe åˆå§‹åŒ– =================
  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  
  hands.onResults((results) => {
    handResults = results;
    // æ ¸å¿ƒå¾ªç¯ï¼šMediaPipe æ¯ä¸€å¸§é©±åŠ¨æ¸¸æˆæ¸²æŸ“
    gameLoop(); 
  });

  const camera = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 1280, height: 720
  });
  camera.start();

  // ================= æ¸¸æˆæµç¨‹æ§åˆ¶ =================
  
  function startGame(mode) {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');

    if (mode === 'fruit') {
      initFruitGame();
    } else if (mode === 'snake') {
      initSnakeGame();
    }
  }

  function initFruitGame() {
    currentState = 'FRUIT_PLAY';
    fruitScore = 0;
    fruitTime = 60;
    cakeCount = 0;
    fruits = [];
    particles = [];
    
    updateFruitUI();
    document.getElementById('fruit-hud').style.display = 'block';
    document.getElementById('snake-hud').style.display = 'none';

    if (fruitTimerRef) clearInterval(fruitTimerRef);
    fruitTimerRef = setInterval(() => {
      fruitTime--;
      updateFruitUI();
      if (fruitTime <= 0) gameOver('æ—¶é—´è€—å°½', 'fruit');
    }, 1000);
  }

  function initSnakeGame() {
    currentState = 'SNAKE_PLAY';
    document.getElementById('fruit-hud').style.display = 'none';
    document.getElementById('snake-hud').style.display = 'block';
    
    // åˆå§‹åŒ–è›‡
    const startX = Math.floor(window.innerWidth / snakeGridSize / 2);
    const startY = Math.floor(window.innerHeight / snakeGridSize / 2);
    snake = [
      { x: startX, y: startY },
      { x: startX, y: startY + 1 },
      { x: startX, y: startY + 2 }
    ];
    snakeDir = { x: 0, y: -1 };
    snakeScore = 0;
    placeSnakeFood();
    document.getElementById('snake-score').innerText = snakeScore;
  }

  function gameOver(reason, fromMode) {
    if (fromMode === 'fruit') clearInterval(fruitTimerRef);
    
    currentState = fromMode === 'fruit' ? 'FRUIT_OVER' : 'SNAKE_OVER';
    
    document.getElementById('fruit-hud').style.display = 'none';
    document.getElementById('snake-hud').style.display = 'none';
    document.getElementById('game-over-screen').classList.remove('hidden');
    
    document.getElementById('go-title').innerText = fromMode === 'fruit' ? "æ¸¸æˆç»“æŸ" : "è´ªåƒè›‡æ’è½¦äº†!";
    document.getElementById('final-score').innerText = fromMode === 'fruit' ? fruitScore : snakeScore;
    document.getElementById('go-reason').innerText = reason;
  }

  function updateFruitUI() {
    document.getElementById('score-val').innerText = fruitScore;
    document.getElementById('timer-val').innerText = fruitTime;
    document.getElementById('cake-val').innerText = cakeCount;
  }

  // ================= ä¸»å¾ªç¯ Render Loop =================
  function gameLoop() {
    // 1. å‡†å¤‡ç”»å¸ƒ
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
    const W = canvasElement.width;
    const H = canvasElement.height;
    
    ctx.clearRect(0, 0, W, H);
    ctx.save();

    // 2. å¤„ç†æ‰‹éƒ¨ä½ç½® & ç»˜åˆ¶éª¨æ¶
    processHand(W, H);

    // 3. æ ¹æ®çŠ¶æ€åˆ†å‘é€»è¾‘
    if (currentState === 'FRUIT_PLAY') {
      updateFruitGame(W, H);
    } else if (currentState === 'SNAKE_PLAY') {
      updateSnakeGame(W, H);
    } else if (currentState === 'FRUIT_OVER' || currentState === 'SNAKE_OVER') {
        // æ¸¸æˆç»“æŸä¹Ÿå¯ä»¥ç®€å•æ›´æ–°ä¸€ä¸‹ç¢ç‰‡åŠ¨ç”»
        updateParticles(W, H); 
    }

    ctx.restore();
  }

  function processHand(W, H) {
    if (handResults && handResults.multiHandLandmarks && handResults.multiHandLandmarks.length > 0) {
      const landmarks = handResults.multiHandLandmarks[0];
      
      // ç»˜åˆ¶å®Œæ•´æ‰‹éª¨æ¶
      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: 'rgba(0, 255, 0, 0.5)', lineWidth: 4});
      drawLandmarks(ctx, landmarks, {color: 'rgba(255, 0, 0, 0.5)', lineWidth: 2});

      // è·å–é£ŸæŒ‡æŒ‡å°– (Index 8)
      const indexTip = landmarks[8];
      handPos = { x: indexTip.x, y: indexTip.y }; // 0-1

      // ç»˜åˆ¶â€œåˆ€å…‰â€ (å¢å¼ºä½“éªŒ)
      const screenX = handPos.x * W;
      const screenY = handPos.y * H;
      
      // å¤–å‘å…‰
      ctx.shadowBlur = 25;
      ctx.shadowColor = "#00f2ff";
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(screenX, screenY, 12, 0, 2 * Math.PI);
      ctx.fill();
      
      // åˆ€é”‹è½¨è¿¹æ„Ÿ (ç®€å•ç”»ä¸ªåœˆ)
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#00f2ff";
      ctx.stroke();
      ctx.shadowBlur = 0; // é‡ç½®

    } else {
      handPos = { x: -1, y: -1 };
    }
  }

  // ================= é€»è¾‘: åˆ‡æ°´æœ =================
  function updateFruitGame(W, H) {
    // ç”Ÿæˆé€»è¾‘
    if (Date.now() - lastSpawnTime > 800) { // ç”Ÿæˆé—´éš”
      spawnFruit(W, H);
      lastSpawnTime = Date.now();
    }

    // æ›´æ–°ç‰©ä½“
    for (let i = fruits.length - 1; i >= 0; i--) {
      let f = fruits[i];
      f.x += f.vx;
      f.y += f.vy;
      f.vy += FRUIT_GRAVITY;
      f.rotation += f.rotSpeed;

      // ç»˜åˆ¶
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rotation);
      ctx.font = `${f.size}px Arial`;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(f.icon, 0, 0);
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform

      // ç¢°æ’æ£€æµ‹ (é£ŸæŒ‡å°–)
      if (handPos.x !== -1) {
        const hx = handPos.x * W;
        const hy = handPos.y * H;
        const dist = Math.hypot(hx - f.x, hy - f.y);
        
        if (dist < f.size / 1.5) {
          // åˆ‡ä¸­
          if (f.type === 'bomb') {
            gameOver('åˆ‡åˆ°ç‚¸å¼¹ ğŸ’¥', 'fruit');
            return;
          } 
          else if (f.type === 'cake') {
            cakeCount++;
            createSliceEffect(f, '#ff9ff3');
            updateFruitUI();
            fruits.splice(i, 1);
            // --- å½©è›‹è§¦å‘åˆ¤æ–­ ---
            if (cakeCount >= 5) {
              clearInterval(fruitTimerRef); // åœæ­¢å€’è®¡æ—¶
              startGame('snake'); // åˆ‡æ¢åˆ°è´ªåƒè›‡
              return;
            }
          } 
          else {
            fruitScore += 10;
            createSliceEffect(f, '#fff');
            updateFruitUI();
            fruits.splice(i, 1);
          }
          continue;
        }
      }

      // ç§»é™¤å‡ºç•Œ
      if (f.y > H + 100) fruits.splice(i, 1);
    }

    updateParticles(W, H);
  }

  function spawnFruit(W, H) {
    const r = Math.random();
    let item;
    if (r < 0.15) item = BOMB_TYPE; // 15% ç‚¸å¼¹
    else if (r < 0.25 && cakeCount < 5) item = CAKE_TYPE; // 10% è›‹ç³•
    else item = { icon: FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)], type: 'fruit' };

    // æé«˜æŠ›å‡ºé«˜åº¦ï¼šåŠ å¤§åˆå§‹ Y é€Ÿåº¦
    // åŸæ¥ vy æ˜¯ -12~-17ï¼Œç°åœ¨è°ƒæ•´ä¸º -18 ~ -25
    const startX = W * 0.1 + Math.random() * W * 0.8;
    const vy = -(18 + Math.random() * 7); 
    const vx = (W/2 - startX) * 0.01 + (Math.random() - 0.5) * 2; // å‘ä¸­é—´é æ‹¢

    fruits.push({
      ...item,
      x: startX, y: H + 50,
      vx: vx, vy: vy,
      rotation: 0, rotSpeed: (Math.random()-0.5)*0.2,
      size: 60
    });
  }

  function createSliceEffect(f, color) {
    for (let i=0; i<2; i++) {
      particles.push({
        icon: f.icon, x: f.x, y: f.y,
        vx: (i===0?-1:1)*3 + f.vx, vy: -5,
        rot: f.rotation, rotSpeed: (i===0?-1:1)*0.1,
        life: 40, half: i // 0å·¦ 1å³
      });
    }
  }

  function updateParticles(W, H) {
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.5;
      p.rot += p.rotSpeed; p.life--;
      
      ctx.globalAlpha = p.life / 40;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      
      // è£å‰ªç»˜åˆ¶åŠä¸ª
      ctx.beginPath();
      ctx.rect(p.half===0 ? -30 : 0, -30, 30, 60);
      ctx.clip();
      ctx.font = "60px Arial";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(p.icon, 0, 0);
      
      ctx.restore(); // æ¢å¤contextçŠ¶æ€ï¼ˆå«alphaå’Œclipï¼‰

      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  // ================= é€»è¾‘: è´ªåƒè›‡ =================
  function updateSnakeGame(W, H) {
    const now = Date.now();
    const cols = Math.floor(W / snakeGridSize);
    const rows = Math.floor(H / snakeGridSize);

    // 1. ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼ (æ·¡è‰²)
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for(let i=0; i<=cols; i++) { ctx.beginPath(); ctx.moveTo(i*snakeGridSize,0); ctx.lineTo(i*snakeGridSize,H); ctx.stroke(); }
    for(let j=0; j<=rows; j++) { ctx.beginPath(); ctx.moveTo(0,j*snakeGridSize); ctx.lineTo(W,j*snakeGridSize); ctx.stroke(); }

    // 2. ç»˜åˆ¶æ§åˆ¶æŒ‡ç¤ºå™¨ (ä¸­å¿ƒåå­—)
    const cx = W / 2, cy = H / 2;
    ctx.strokeStyle = 'rgba(46, 213, 115, 0.3)';
    ctx.beginPath(); ctx.moveTo(cx, cy-50); ctx.lineTo(cx, cy+50); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx-50, cy); ctx.lineTo(cx+50, cy); ctx.stroke();

    // 3. æ ¹æ®æ‰‹ä½ç½®å†³å®šæ–¹å‘ (è™šæ‹Ÿæ‘‡æ†)
    if (handPos.x !== -1) {
        // ç®€å•çš„å››ä¸ªè±¡é™åˆ¤æ–­
        // å¿…é¡»ç¦»å¼€ä¸­å¿ƒä¸€å®šè·ç¦»æ‰è½¬å‘ï¼Œé˜²æ­¢æŠ–åŠ¨ (Deadzone)
        const deadZone = 0.15; 
        const dx = handPos.x - 0.5;
        const dy = handPos.y - 0.5;

        // æ˜¾ç¤ºå½“å‰æŒ‡ä»¤
        let dirText = "";
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx < -deadZone && snakeDir.x !== 1) { snakeDir = {x: -1, y: 0}; dirText = "â¬…ï¸"; }
            else if (dx > deadZone && snakeDir.x !== -1) { snakeDir = {x: 1, y: 0}; dirText = "â¡ï¸"; }
        } else {
            if (dy < -deadZone && snakeDir.y !== 1) { snakeDir = {x: 0, y: -1}; dirText = "â¬†ï¸"; }
            else if (dy > deadZone && snakeDir.y !== -1) { snakeDir = {x: 0, y: 1}; dirText = "â¬‡ï¸"; }
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨ä½ç½®å’Œæ–¹å‘æç¤º
        ctx.fillStyle = "#2ed573";
        ctx.beginPath(); ctx.arc(handPos.x * W, handPos.y * H, 10, 0, 2*Math.PI); ctx.fill();
        if(dirText) {
            ctx.font = "40px Arial";
            ctx.fillText(dirText, cx, cy);
        }
    }

    // 4. ç§»åŠ¨æ›´æ–° (å®šæ—¶å™¨)
    if (now - snakeMoveTimer > snakeMoveInterval) {
        snakeMoveTimer = now;
        
        const head = { x: snake[0].x + snakeDir.x, y: snake[0].y + snakeDir.y };

        // æ’å¢™åˆ¤å®š
        if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
            gameOver("æ’å¢™å•¦!", 'snake');
            return;
        }
        // æ’è‡ªå·±åˆ¤å®š
        for (let part of snake) {
            if (head.x === part.x && head.y === part.y) {
                gameOver("å’¬åˆ°è‡ªå·±å•¦!", 'snake');
                return;
            }
        }

        snake.unshift(head); // åŠ å¤´

        // åƒé£Ÿç‰©
        if (head.x === snakeFood.x && head.y === snakeFood.y) {
            snakeScore++;
            document.getElementById('snake-score').innerText = snakeScore;
            placeSnakeFood();
            // ç¨å¾®åŠ é€Ÿ
            snakeMoveInterval = Math.max(50, snakeMoveInterval - 2);
        } else {
            snake.pop(); // å»å°¾
        }
    }

    // 5. ç»˜åˆ¶è›‡å’Œé£Ÿç‰©
    // é£Ÿç‰©
    ctx.font = "24px Arial";
    ctx.fillText("ğŸ", snakeFood.x * snakeGridSize + snakeGridSize/2, snakeFood.y * snakeGridSize + snakeGridSize/2);

    // è›‡
    ctx.fillStyle = "#2ed573";
    snake.forEach((part, index) => {
        const px = part.x * snakeGridSize;
        const py = part.y * snakeGridSize;
        // å¤´é¢œè‰²æ·±ä¸€ç‚¹
        if (index === 0) ctx.fillStyle = "#26af61";
        else ctx.fillStyle = "#2ed573";
        
        ctx.fillRect(px + 2, py + 2, snakeGridSize - 4, snakeGridSize - 4);
    });
  }

  function placeSnakeFood() {
    const cols = Math.floor(window.innerWidth / snakeGridSize);
    const rows = Math.floor(window.innerHeight / snakeGridSize);
    snakeFood = {
        x: Math.floor(Math.random() * cols),
        y: Math.floor(Math.random() * rows)
    };
  }

</script>
</body>
</html>